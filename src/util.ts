import * as assert from 'assert'
import { logger as log } from './logger'
import * as t from 'io-ts'
import { PathReporter } from 'io-ts/lib/PathReporter'
import { URL } from 'url'
import * as R from 'ramda'
import { Context as LambdaContext, APIGatewayEvent, Callback as LambdaCallback } from 'aws-lambda'

export const urlToBucketName = (s3Url: string): string => {
  const u = new URL(s3Url)
  if (u.protocol === 's3:') {
    return u.host
  } else if (u.protocol === 'https:') {
    // Host is region.awshost, path starts with bucket
    const p = u.pathname.substring(1).split('/')
    assert.ok(p && p.length > 0)
    return p[0]
  } else {
    throw new Error('Unsupported protocol: ' + s3Url)
  }
}

export const urlToKeyName = (s3Url: string): string => {
  const u = new URL(s3Url)
  if (u.protocol === 's3:') {
    return u.pathname.substring(1)
  } else if (u.protocol === 'https:') {
    // Host is region.awshost, path starts with bucket
    const p = u.pathname.substring(1).split('/')
    assert.ok(p && p.length > 0)
    p.splice(0, 1)
    return p.join('/')
  } else {
    throw new Error('Unsupported protocol: ' + s3Url)
  }
}

/** Assert something and pass something */
export const passert = <T>(value: any | undefined | null, result: T | null | undefined): T => {
  assert.ok(value)
  return result as NonNullable<T>
}

/** Log something and pass something */
export const plog = <T>(msg: string, meta: any | undefined, result: T): T => {
  log.info(msg, JSON.stringify(meta))
  return result
}

/** Decode or throw exception */
export const decode = <T>(
  type: t.TypeC<any> | t.IntersectionC<any> | t.PartialC<any>,
  json: string | undefined | null | any,
) => {
  assert.ok(json, 'Incoming JSON is either a string or an object: ' + json)
  const res = type.decode(typeof json === 'string' ? JSON.parse(json!) : json)
  const value = res.getOrElseL(_ => {
    throw new Error('Invalid value ' + JSON.stringify(PathReporter.report(res)))
  })
  // Filter undefined
  return R.pick(R.filter(k => value[k] !== undefined, R.keys(value)) as string[], value) as T
}

export const toThrow = (err: any, msg?: string) =>
  new Error(err && err && err.message && err.message + (msg && ' ' + msg))

export const noext = (path: string) => {
  return path.substring(0, path.lastIndexOf('.'))
}

export const ext = (path: string) => {
  return path.substring(path.lastIndexOf('.') + 1)
}

/**
 * Finds payload when called as AWS Lambda. Tries to handle API Gateway, S3 events in uniform fashion.
 *
 * @param event AWS Lambda event or any payload, either generated by AWS Console UI or manually
 */
export const findPayload = (event): any => {
  // Invoked directly at AWS Lambda console or via serverless invoke
  const simplePayload = event.body === undefined
  const payload = simplePayload ? (event as any) : event.body
  return payload
}

export interface ApiResponseHandler {
  success(payload: any, statusCode?: number /* = 200 */, headers?: any): void
  failure(
    payload?: any /* = "Internal server error"*/,
    statusCode?: number /* = 500 */,
    headers?: any,
  ): void
}

/**
 * Generates response compatible with AWS Lambda, API Gateway, S3 events
 *
 * @param event AWS Lambda event or any payload, either generated by AWS Console UI or manually
 * @param context AWS Lambda context
 * @param callback Callback function
 */
export const apiResponse = (
  event: APIGatewayEvent,
  context: LambdaContext,
  callback: LambdaCallback,
): ApiResponseHandler => {
  const simplePayload = event.body === undefined

  // Don`t wrap if it is a simple payload, return only body
  // It is used when we have AWS Lambda direct invocation
  const cb = simplePayload
    ? (_, response) => {
        log.info(
          `Response function ${context.functionName}, requestId = ${context.awsRequestId}, status ${response.statusCode}`,
        )
        return callback(null, JSON.parse(response.body))
      }
    : (_, response) => {
        log.info(
          `Response function ${context.functionName}, requestId = ${context.awsRequestId}, status ${response.statusCode}`,
        )
        return callback(null, response)
      }

  return {
    /**
     * Call success to finish Lambda invocation and return data
     */
    success: (payload: any, statusCode: number = 200, headers: any = undefined) => {
      // Don`t wait for event loop to drain
      context.callbackWaitsForEmptyEventLoop = false

      return cb(null, {
        statusCode,
        headers: {
          ...headers,
          // Required for CORS support to work
          'Access-Control-Allow-Origin': '*',
          // Required for cookies, authorization headers with HTTPS
          'Access-Control-Allow-Credentials': true,
        },
        body: JSON.stringify(payload),
      })
    },
    /**
     * Call to return 500 (by default error) and specify either error JSON body, string or undefined
     * If not specified or a string, will produce { message: "<str> | Internal server error" } payload
     */
    failure: (payload: any = undefined, statusCode: number = 500, headers: any = undefined) => {
      // Don`t wait for event loop to drain
      context.callbackWaitsForEmptyEventLoop = false

      return cb(null, {
        statusCode,
        headers: {
          ...headers,
          // Required for CORS support to work
          'Access-Control-Allow-Origin': '*',
          // Required for cookies, authorization headers with HTTPS
          'Access-Control-Allow-Credentials': true,
        },
        body:
          typeof payload === 'string'
            ? JSON.stringify({ message: payload })
            : JSON.stringify(payload || { message: 'Internal server error' }),
      })
    },
  }
}
